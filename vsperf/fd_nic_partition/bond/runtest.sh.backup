#!/bin/bash
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#   runtest.sh of /kernel/networking/fd_nic_partition/bond
#   Author: Hekai Wang <hewang@redhat.com>
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#   Copyright (c) 2013 Red Hat, Inc.
#
#   This copyrighted material is made available to anyone wishing
#   to use, modify, copy, or redistribute it subject to the terms
#   and conditions of the GNU General Public License version 2.
#
#   This program is distributed in the hope that it will be
#   useful, but WITHOUT ANY WARRANTY; without even the implied
#   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
#   PURPOSE. See the GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public
#   License along with this program; if not, write to the Free
#   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
#   Boston, MA 02110-1301, USA.
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# variables
set -x
PACKAGE="kernel"
CASE_PATH=${CASE_PATH:-"/mnt/tests/kernel/networking/fd_nic_partition/bond"}

. /etc/os-release
SYSTEM_VERSION_ID=`echo $VERSION_ID | tr -d '.'`

source /mnt/tests/kernel/networking/common/include.sh || exit 1
source /mnt/tests/kernel/networking/common/lib/lib_nc_sync.sh || exit 1
source /mnt/tests/kernel/networking/common/lib/lib_netperf_all.sh || exit 1
source ${CASE_PATH}/env.sh || exit 1


pytool()
{
    python tools.py $*
}

pyxmltool()
{
    python xmltool.py $*
}

check_install()
{
	local pkg_name=$1
	echo "***************************************"
	rpm -q $pkg_name || yum -y install $pkg_name
	echo "***************************************"
	return 0
}

install_init_package()
{
	pushd $CASE_PATH

	local all_packs=(
		wget
		git
		gcc
		make
		bc
		lsof
		nmap-ncat
		tcpdump
		expect
        ethtool
        yum-utils
	)
	for pack in "${all_packs[@]}"
	do
		check_install $pack
	done
	
	if (( $SYSTEM_VERSION_ID < 80 ))
	then
		check_install bridge-utils
	fi

	popd
}


add_epel_repo()
{
	if (( $SYSTEM_VERSION_ID < 80 ))
	then
		yum -y install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm
	else
		dnf -y install epel-release
	fi

}

install_package()
{
	add_epel_repo
	if (( $SYSTEM_VERSION_ID < 80 ))
	then
		yum -y install qemu-img-rhev 
		yum -y install qemu-kvm-common-rhev
		yum -y install qemu-kvm-rhev 
		yum -y install qemu-kvm-tools-rhev
	else
		yum install -y qemu-img 
		yum -y install qemu-kvm 
		yum -y install platform-python-devel
	fi

	local all_pack=(
		lrzip 
		tcpdump 
		python36
		ethtool 
		yum-utils 
		scl-utils 
		libnl3-devel
		python36-devel
		wget 
		nano 
		ftp 
		git 
		tuna 
		openssl 
		sysstat
		tuned-profiles-cpu-partitioning
		libvirt 
		libvirt-devel 
		virt-install 
		virt-manager 
		virt-viewer
		czmq-devel
		libguestfs-tools
		ethtool
		libvirt-devel
		libvirt-python
		python3-lxml
		emacs 
		gcc 
		git 
		lshw 
		pciutils 
	)

	for pack in "${all_pack[@]}"
	do
		check_install $pack
	done

	#for qemu bug that can not start qemu
	if (( $SYSTEM_VERSION_ID < 80 ))
	then
		echo -e "group = 'hugetlbfs'" >> /etc/libvirt/qemu.conf
	fi
	
	systemctl restart libvirtd
	systemctl start virtlogd.socket
	
	# work around for failure of virt-install
	chmod 666 /dev/kvm

}

get_nic_name_from_mac()
{
	local mac_addr=$1
    local nic_name
    nic_name=`pytool get_nic_name_from_mac $mac_addr`
    echo $nic_name
}

init_python_env()
{
	if (( $SYSTEM_VERSION_ID >= 80 ))
	then
		python3 -m venv ${CASE_PATH}/venv
	else
		python36 -m venv ${CASE_PATH}/venv
	fi

	source venv/bin/activate
	export PYTHONPATH=${CASE_PATH}/venv/lib64/python3.6/site-packages/
	pip install --upgrade pip

	pip install fire
	pip install psutil
	pip install paramiko
	pip install xmlrunner
	pip install netifaces
	pip install argparse
	pip install plumbum
	pip install ethtool
	pip install shell
    pip install libvirt-python
    pip install envbash
    pip install bash
}

get_pmd_masks()
{
	local cpus=$1
	local pmd_mask
	#local cpu_array=($cpus)
	pmd_mask=`python tools.py get-pmd-masks "${cpus}"`
	echo $pmd_mask
}

get_isolate_cpus()
{
	local nic_name=$1
	local isolate_cpus=$(python tools.py get-isolate-cpus-with-nic $nic_name)
	echo $isolate_cpus
}

config_isolated_cpu_and_Gb_hugepage()
{
	rpm -q grubby || yum -y install grubby
	rpm -qa | grep tuned-profiles-cpu-partitioning || yum -y install tuned-profiles-cpu-partitioning

	local cpus=$1
	local hpage_num=$2

	echo -e "isolated_cores=${cpus}" >> /etc/tuned/cpu-partitioning-variables.conf
	tuned-adm profile cpu-partitioning
	
	local hpage_cmd_line="nohz=on \
	default_hugepagesz=1G hugepagesz=1G \
	hugepages=${hpage_num} intel_iommu=on iommu=pt \
	modprobe.blacklist=qedi modprobe.blacklist=qedf modprobe.blacklist=qedr"

	local default_kernel=$(grubby --default-kernel)

	grubby --args="${hpage_cmd_line}" --update-kernel ${default_kernel}

	#here make a mark file for reboot check , please do not remove it 
	touch /tmp/nic_cert_file 
}

add_yum_profiles()
{
    if (( $SYSTEM_VERSION_ID < 80 ));then
        local latest_qemu_rpm='http://download.lab.bos.redhat.com/rcm-guest/puddles/OpenStack/rhos-release/rhos-release-latest.noarch.rpm'
        yum install -y ${latest_qemu_rpm}
        test -f /etc/yum.repos.d/rhos-release-13.repo || install /var/lib/rhos-release/repos/rhos-release-13.repo /etc/yum.repos.d/

		rpm --import "http://keyserver.ubuntu.com/pks/lookup?op=get&search=0x3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF"
		local tuned_repo=(
				"[tuned]"
				"name=Tuned development repository for RHEL-7"
				"baseurl=https://fedorapeople.org/~jskarvad/tuned/devel/repo/"
				"enabled=1"
				"gpgcheck=0"
				"skip_if_unavailable=1"
				"[tuned]"
				"name=mono-repo"
				"baseurl=http://download.mono-project.com/repo/centos/"
				"enabled=1"
				"gpgcheck=0"
				"skip_if_unavailable=1"
		)
		printf "%s\n" "${tuned_repo[@]}" >> /etc/yum.repos.d/tuned.repo

    fi
}

install_ovs()
{
    local ovs_version=${OVS_URL##*/}
    ovs_version=${ovs_version%.rpm}
    if rpm -q $ovs_version;then
        true;
    else
        yum -y install ${CONTAINER_SELINUX_URL}
        yum install -y ${OVS_SELINUX_URL}
        rpm -ivh ${OVS_URL}
    fi
}

install_driverctl()
{
    rpm -qa | grep `basename ${DRIVERCTL_URL}` || yum install -y ${DRIVERCTL_URL}
}

install_dpdk()
{
    rpm -qa | grep `basename ${DPDK_URL}` || rpm -ivh ${DPDK_URL}
    rpm -qa | grep `basename ${DPDK_TOOL_URL}` || rpm -ivh ${DPDK_TOOL_URL}
}

init_netscout_tool()
{
	netscout_url=https://github.com/ctrautma/NetScout.git
    scout_dir=`echo ${netscout_url##*/} | awk -F . '{print $1}'`
    if [ ! -d ${CASE_PATH}/$scout_dir ];then
    	git clone $netscout_url
    fi
    pushd $scout_dir
    git checkout bddc7bdf5a4fc9cfb9cd73f2cfc0d731af6b0bd1
    chmod 777 NSConnect.py
    popd
}

scout_connect()
{
    local port1=$1
    local port2=$2

    pushd $scout_dir
    echo "NETSCOUT CONNECT PORT $port1 AND $port2"
	if (( $SYSTEM_VERSION_ID >= 80 ))
	then
	    python3 NSConnect.py --connect $port1 $port2
	else
		python36 NSConnect.py --connect $port1 $port2
	fi
    popd
}

scout_disconnect()
{
    local port1=$1
    local port2=$2
    pushd $scout_dir
    echo "NETSCOUT DISCONNECT PORT $port1 AND $port2"
	if (( $SYSTEM_VERSION_ID >= 80 ))
	then
        python3 NSConnect.py --disconnect $port1 $port2
    else
        python36 NSConnect.py --disconnect $port1 $port2
    fi
    popd
}

scout_show()
{
    pushd $scout_dir
    . /etc/os-release
	if (( $SYSTEM_VERSION_ID >= 80 ))
	then
        python3 NSConnect.py --showconnections
    else
        python36 NSConnect.py --showconnections
    fi
    popd
}

init_netscout_config()
{
    pushd $scout_dir
    if [[ $NETSCOUT_HOST != "" ]]
    then
        host_name=`echo -n $NETSCOUT_HOST | base64`
    else
        host_name='YWRtaW5pc3RyYXRvcg=='
    fi
    local netscout_config=(
        "[INFO]"
		"password = bmV0c2NvdXQx"
		"username = YWRtaW5pc3RyYXRvcg=="
		"port = NTMwNTg="
		"host = $host_name"
    )
	printf "%s\n" "${netscout_config[@]}" > $CASE_PATH/$scout_dir/settings.cfg

    popd
}

init_physical_topo_without_switch()
{
    init_netscout_tool
    init_netscout_config

    if [[ $CONN_TYPE == "netscout" ]]
    then
        scout_connect $SERVER_PORT_ONE $CLIENT_PORT_ONE
        scout_connect $SERVER_PORT_TWO $CLIENT_PORT_TWO
    else
        echo "DO NOTHING,JUST FOR CUSTOMER PFT TEST"        
    fi
}


init_physical_topo_with_switch()
{
    init_netscout_tool
    init_netscout_config
    if [[ $CONN_TYPE == "netscout" ]]
    then
        if [[ $TRAFFIC_TYPE == "xena" ]]
        then
            scout_connect $TRAFFIC_PORT_ONE $SWITCH_PORT_THREE
            scout_connect $TRAFFIC_PORT_TWO $SWITCH_PORT_FOUR
            scout_connect $SERVER_PORT_ONE $SWITCH_PORT_ONE
            scout_connect $SERVER_PORT_TWO $SWITCH_PORT_TWO
        elif [[ $TRAFFIC_TYPE == "trex" ]]
        then
            scout_connect $SERVER_PORT_ONE $SWITCH_PORT_ONE
            scout_connect $SERVER_PORT_TWO $SWITCH_PORT_TWO
            scout_connect $CLIENT_PORT_ONE $SWITCH_PORT_THREE
            scout_connect $CLIENT_PORT_TWO $SWITCH_PORT_FOUR
        else
            echo "INVLIAD BOND TEST MODE , PLEASE CHECK!!"            
        fi
    else
        echo "DO NOTHING,JUST FOR CUSTOMER PFT TEST"        
    fi
}

config_hugepage()
{

	if i_am_server; then
        local server_nic=`pytool get_nic_name_from_mac $SERVER_NIC1_MAC`
        local server_cpu=`get_isolate_cpus $server_nic`
        config_isolated_cpu_and_Gb_hugepage "${server_cpu// /,}" 24
	elif i_am_client; then
        local client_nic=`pytool get_nic_name_from_mac $CLIENT_NIC1_MAC`
        local client_cpu=`get_isolate_cpus $client_nic`
        config_isolated_cpu_and_Gb_hugepage "${client_cpu// /,}" 24
    else
        echo "Error Rule for config huge page"
	fi

	rhts-reboot
	cat /proc/cmdline
}

loginfo()
{
    echo "************************************************"
    echo "$*"
    echo "************************************************"
}

enable_dpdk() 
{
    install_dpdk
    install_driverctl
    local nic1_mac=$1
    local nic2_mac=$2
    local nic1_name=`get_nic_name_from_mac $nic1_mac`
    local nic2_name=`get_nic_name_from_mac $nic2_mac`
    local nic1_businfo=$(ethtool -i $nic1_name | grep "bus-info" | awk  '{print $2}')
    local nic2_businfo=$(ethtool -i $nic2_name | grep "bus-info" | awk  '{print $2}')
    modprobe -r vfio-pci
    modprobe -r vfio
    modprobe vfio-pci
    modprobe vfio
    local driver_name=`ethtool -i $nic1_name | grep driver | awk '{print $NF}'`
    if [ "$driver_name" == "mlx5_core" ];then
        loginfo "This Driver is Mallenox , So just return 0"
        return 0
    fi

    if [[ -f /usr/share/dpdk/usertools/dpdk-devbind.py ]]; then
        echo "using dpdk-devbind.py set the vfio-pci driver to nic"
        /usr/share/dpdk/usertools/dpdk-devbind.py -b vfio-pci ${nic1_businfo}
        /usr/share/dpdk/usertools/dpdk-devbind.py -b vfio-pci ${nic2_businfo}
        /usr/share/dpdk/usertools/dpdk-devbind.py --status
    else
        echo "using driverctl set the vfio-pci driver to nic"
        driverctl -v set-override $nic1_businfo vfio-pci
        sleep 3
        driverctl -v set-override $nic2_businfo vfio-pci
        sleep 3
        driverctl -v list-devices|grep vfio-pci
    fi
}

enable_openvswitch_as_root_user()
{
    for i in "nfp" "broadcom" "xxv"
    do
        if [[ "$NIC_DRIVER" == "$i" ]];then
            #here need update /etc/sysconfig/openvswitch
            sed -ie 's/OVS_USER_ID/#OVS_USER_ID/g' /etc/sysconfig/openvswitch 
            break
        fi
    done
}

bonding_nic() 
{
    local nic1_mac=$1
    local nic2_mac=$2
    local bond_mode=$3
    local mtu_val=$4
    
    # enable_openvswitch_as_root_user

    local pmd_cpu_mask
    if i_am_server;then
        pmd_cpu_mask=$SERVER_PMD_CPU_MASK
    elif i_am_client;then
        pmd_cpu_mask=$CLIENT_PMD_CPU_MASK
    fi

    

	modprobe openvswitch
	systemctl stop openvswitch
	sleep 3
	systemctl start openvswitch
	sleep 3

	ovs-vsctl --if-exists del-br ovsbr0
	sleep 5

	ovs-vsctl set Open_vSwitch . other_config={}
	ovs-vsctl --no-wait set Open_vSwitch . other_config:dpdk-init=true
	ovs-vsctl --no-wait set Open_vSwitch . other_config:dpdk-socket-mem="4096,4096"
	ovs-vsctl set Open_vSwitch . other_config:pmd-cpu-mask="$pmd_cpu_mask"
    ovs-vsctl --no-wait set Open_vSwitch . other_config:vhost-iommu-support=true
	systemctl restart openvswitch
	sleep 3
	ovs-vsctl add-br ovsbr0 -- set bridge ovsbr0 datapath_type=netdev

    ovs-vsctl add-bond ovsbr0 dpdkbond dpdk0 dpdk1 "bond_mode=${bond_mode}" \
    -- set Interface dpdk0 type=dpdk options:dpdk-devargs=class=eth,mac=${nic1_mac} mtu_request=${mtu_val} \
    -- set Interface dpdk1 type=dpdk options:dpdk-devargs=class=eth,mac=${nic2_mac} mtu_request=${mtu_val}

    #set dpdkbond port with vlan mode trunk and permit all vlans
    ovs-vsctl set Port dpdkbond vlan_mode=trunk
    ovs-vsctl list Port dpdkbond

    #set updelay and downdelay for test
    ovs-vsctl set Port dpdkbond bond_updelay=5
    ovs-vsctl set Port dpdkbond bond_downdelay=5

    local updelay=`ovs-vsctl list Port dpdkbond | grep bond_updelay | awk '{print $NF}'`
    local downdelay=`ovs-vsctl list Port dpdkbond | grep bond_downdelay | awk '{print $NF}'`
    rlAssertEquals "Check bond up delay time " "$updelay" "5"
    rlAssertEquals "Check bond down delay time " "$downdelay" "5"
    ovs-vsctl list Port dpdkbond
	
    #ovs-vsctl add-port ovsbr0 vhost0 -- set interface vhost0 type=dpdkvhostuser
    ovs-vsctl add-port ovsbr0 vhost0 -- set interface vhost0 type=dpdkvhostuserclient options:vhost-server-path=/tmp/vhost0
	#chmod 777 /var/run/openvswitch/vhost0

	ovs-ofctl del-flows ovsbr0
	ovs-ofctl add-flow ovsbr0 actions=NORMAL

	sleep 2
	ovs-vsctl show
	sleep 5
	echo "after bonding nic, check the bond status"
	ovs-appctl bond/show
    sleep 30
    ovs-appctl bond/show
}


start_libvirtd_service()
{
    systemctl list-units --state=stop --type=service | grep libvirtd || systemctl restart libvirtd
}

start_guest()
{
    start_libvirtd_service
    local image_name=`basename ${IMG_GUEST}`
    [[ -f /root/rhel.qcow2 ]] && rm -f /root/rhel.qcow2
    wget -P /root/ ${IMG_GUEST} > /dev/null 2>&1
    pushd /root/
        mv $image_name rhel.qcow2
    popd
    chmod 777 /root/
    local udev_file=60-persistent-net.rules
    touch $udev_file
    cat > $udev_file <<EOF
ACTION=="add", SUBSYSTEM=="net", DRIVERS=="?*", ATTR{address}=="52:54:00:11:8f:ea", NAME="eth1"
ACTION=="add", SUBSYSTEM=="net", DRIVERS=="?*", ATTR{address}=="52:54:00:11:8f:eb", NAME="eth1"
ACTION=="add", SUBSYSTEM=="net", DRIVERS=="?*", ATTR{address}=="52:54:00:bb:63:7b", NAME="eth2"
EOF

    virt-copy-in -a /root/rhel.qcow2 $udev_file /etc/udev/rules.d/
    #Here add dpdk rpm to guest
    rm -rf /root/${GUEST_DPDK_VERSION}
    mkdir -p /root/${GUEST_DPDK_VERSION}
    wget -P /root/${GUEST_DPDK_VERSION}/ ${GUEST_DPDK_URL}      > /dev/null 2>&1
    wget -P /root/${GUEST_DPDK_VERSION}/ ${GUEST_DPDK_TOOL_URL} > /dev/null 2>&1
    virt-copy-in -a /root/rhel.qcow2 /root/${GUEST_DPDK_VERSION}/ /root/
    sleep 5
    
    virsh define ${CASE_PATH}/g1.xml
    chmod 777 /root/
    virsh start guest30032

}

destroy_guest()
{
    virsh destroy guest30032
    virsh undefine guest30032
}

configure_guest()
{
	local cmd=(
            {nmcli dev set eth1 managed no}
            {systemctl stop firewalld}
            {iptables -t filter -P INPUT ACCEPT}
			{iptables -t filter -P FORWARD ACCEPT}
			{iptables -t filter -P OUTPUT ACCEPT}
			{iptables -t mangle -P PREROUTING ACCEPT}
			{iptables -t mangle -P INPUT ACCEPT}
			{iptables -t mangle -P FORWARD ACCEPT}
			{iptables -t mangle -P OUTPUT ACCEPT}
			{iptables -t mangle -P POSTROUTING ACCEPT}
			{iptables -t nat -P PREROUTING ACCEPT}
			{iptables -t nat -P INPUT ACCEPT}
			{iptables -t nat -P OUTPUT ACCEPT}
			{iptables -t nat -P POSTROUTING ACCEPT}
			{iptables -t filter -F}
			{iptables -t filter -X}
			{iptables -t mangle -F}
			{iptables -t mangle -X}
			{iptables -t nat -F}
			{iptables -t nat -X}
			{ip6tables -t filter -P INPUT ACCEPT}
			{ip6tables -t filter -P FORWARD ACCEPT}
			{ip6tables -t filter -P OUTPUT ACCEPT}
			{ip6tables -t mangle -P PREROUTING ACCEPT}
			{ip6tables -t mangle -P INPUT ACCEPT}
			{ip6tables -t mangle -P FORWARD ACCEPT}
			{ip6tables -t mangle -P OUTPUT ACCEPT}
			{ip6tables -t mangle -P POSTROUTING ACCEPT}
			{ip6tables -t nat -P PREROUTING ACCEPT}
			{ip6tables -t nat -P INPUT ACCEPT}
			{ip6tables -t nat -P OUTPUT ACCEPT}
			{ip6tables -t nat -P POSTROUTING ACCEPT}
			{ip6tables -t filter -F}
			{ip6tables -t filter -X}
			{ip6tables -t mangle -F}
			{ip6tables -t mangle -X}
			{ip6tables -t nat -F}
			{ip6tables -t nat -X}
            {dhclient -v eth2}
			{ip addr add $1/24 dev eth1}
            {ip -d addr show}
                )

	vmsh cmd_set guest30032 "${cmd[*]}"
}


update_ssh_trust()
{
    mkdir -p ~/.ssh
    rm -f ~/.ssh/*
    touch ~/.ssh/known_hosts
    chmod 644 ~/.ssh/known_hosts
    ssh-keyscan $TREX_SERVER_IP >> ~/.ssh/known_hosts
    echo 'y\n' | ssh-keygen -f ~/.ssh/id_rsa -t rsa -N ''
    python tools.py config-ssh-trust ~/.ssh/id_rsa.pub $TREX_SERVER_IP root ${TREX_SERVER_PASSWORD}
}

clear_dpdk_interface()
{
    if rpm -qa | grep dpdk-tools
    then
        local bus_list=`dpdk-devbind -s | grep  -E drv=vfio-pci\|drv=igb | awk '{print $1}'`
        for i in $bus_list
        do
            kernel_driver=`lspci -s $i -v | grep Kernel  | grep modules  | awk '{print $NF}'`
            dpdk-devbind -b $kernel_driver $i
        done
        dpdk-devbind -s
    fi
    return 0
}

clear_env()
{
    modprobe -r bonding
    start_libvirtd_service
    ovs-vsctl --if-exists del-br ovsbr0
    systemctl restart libvirtd
    virsh list | grep guest30032 && (virsh destroy guest30032 && virsh undefine guest30032)
    virsh list --all | grep guest30032 && (virsh undefine guest30032)
    systemctl stop openvswitch

    clear_trex
    clear_dpdk_interface
    clear_hugepage
    if i_am_server; then
        local nic1_name=`get_nic_name_from_mac $SERVER_NIC1_MAC`
        local nic2_name=`get_nic_name_from_mac $SERVER_NIC2_MAC`
        ip link set $nic1_name down
        ip link set $nic2_name down
    elif i_am_client; then
        local nic1_name=`get_nic_name_from_mac $CLIENT_NIC1_MAC`
        local nic2_name=`get_nic_name_from_mac $CLIENT_NIC2_MAC`
        ip link set $nic1_name down
        ip link set $nic2_name down
    else
        echo "Here wrong rule"        
    fi

    return 0
}

ovs_tcpdump_install()
{
    rpm -ivh ${PYTHON_OVS_URL} --nodeps
    rpm -ivh ${OVS_TEST_URL} --nodeps
    return 0
}


install_trex_and_start()
{
    local nic1_mac=$1
    local nic2_mac=$2
    local trex_url=$3
    pushd $CASE_PATH
    #first need update /etc/yum.repos.d/beaker-tasks.repo , update the baseurl item
    sed -i 's/baseurl.*/baseurl\=http\:\/\/beaker.engineering.redhat.com\/rpms/g' /etc/yum.repos.d/beaker-tasks.repo
    yum -y clean all
    install_dpdk
    install_driverctl
    yum -y install emacs gcc git lshw pciutils python-devel python-setuptools python-pip tmux tuned-profiles-cpu-partitioning wget

    trex_name=`basename ${trex_url}`
    trex_dir=`basename -s .tar.gz ${trex_url}`
    [ -d ${trex_dir} ] || wget ${trex_url} > /dev/null 2>&1
    [ -d ${trex_dir} ] || tar -xvf $trex_name > /dev/null 2>&1
    pushd $trex_dir
    local nic1_name=`get_nic_name_from_mac $nic1_mac`
    local nic2_name=`get_nic_name_from_mac $nic2_mac`
    local nic1_bus=`ethtool -i $nic1_name | grep bus-info | awk '{print $NF}'`
    local nic2_bus=`ethtool -i $nic2_name | grep bus-info | awk '{print $NF}'`
    local nic_bus="$nic1_bus $nic2_bus"
    rm -f /etc/trex_cfg.yaml
    ./dpdk_setup_ports.py -c $nic_bus --force-macs --no-ht -o /etc/trex_cfg.yaml
    local isolate_cpus=`grep threads /etc/trex_cfg.yaml  | awk '{print $NF}' | tr -d []`

    systemctl enable tuned
    systemctl start tuned

    enable_dpdk $nic1_mac $nic2_mac
    #nohup ./t-rex-64 -i > /dev/null 2>&1 &
    ./trex_daemon_server restart
    sleep 10
    popd
    
    popd
}


clear_hugepage()
{
    local hugepage_dir=`mount -l | grep hugetlbfs | awk '{print $3}'`
    rm -rf $hugepage_dir/*
    return 0
}

clear_trex()
{
    pkill t-rex-64
    pkill t-rex-64
    pkill _t-rex-64
    pkill _t-rex-64
    return 0
}

clear_trex_and_free_hugepage()
{
    clear_trex
    clear_hugepage
    return 0
}


py_sriov()
{
    pushd $CASE_PATH/../common/ > /dev/null
    #echo "args "$* > /dev/null
    python lib_sriov.py $*
    popd > /dev/null
}


#create vf from pf nic name with special num
vf_create()
{
    local pf=$1
    local num=$2
    local pf_bus=`py_sriov sriov_get_pf_bus_from_pf_name $pf`
    py_sriov sriov_create_vfs $pf_bus $num
    for i in `seq $num`
    do
        ip li set $pf vf $i spoofchk off trust on
    done
}

vf_mac_config()
{
    local pf_name=$1
    local vf_index=$2
    local mac_addr=$3
    #To set the vNIC MAC address on the Virtual Function, use the command:
    ip link set $pf_name vf $vf_index mac $mac_addr
}

vf_mtu_change()
{
    local vf_name=$1
    local mtu_val=$2
    ip link set $vf_name up
    
    if (( $mtu_val <= 1500 ))
    then
        ip link set $vf_name mtu 1500
    elif ((  $mtu_val > 1500 && $mtu_val <=9200 ))
    then
        ip link set $vf_name mtu $mtu_val
    else
        ip link set $vf_name mtu 9200
    fi    
}

vf_qos_bandwidth_config()
{
    local pf_name=$1
    local vf_index=$2
    local min_rate=$3
    local max_rate=$4
    
    # ip link set <PF_IF_NAME> vf <VF_IDX> max_tx_rate <MAX_RATE_IN_MBIT/S> min_tx_rate <MIN_RATE_IN_MBIT/S>
    #Example to enable rate limiting of 1000Mb/s and minimum of 10Mb/s:
    ip link set $pf_name vf $vf_index max_tx_rate $max_rate min_tx_rate $min_rate
    #To disable or stop the rate limit per VF, set the rate to 0.
    #ip link set ens785f1 vf 0 max_tx_rate 0 min_tx_rate 0
}

vf_vlan_tag_and_qos_config()
{
    local pf_name=$1
    local vf_name=$2
    local vf_index=$3
    local vlan_id=$4
    local qos_val=$5
    #For example: Here eth2 is the PF (physical function) , eth8 is the interface assigned to VF 1.
    #ip link set eth8 down 
    #ip link set eth2 vf 1 vlan 2 qos 2 
    #ip link set eth8 up

    ip link set $vf_name down 
    ip link set $pf_name vf $vf_index vlan $vlan_id qos $qos_val
    ip link set $vf_name up

}

vf_trust_config()
{
    local pf_name=$1
    local vf_index=$2
    local trust_val=$3
    #Allow VF to run in promiscuous mode and receive packets with multiple VLAN or QinQ headers to be sent to VM without stripping
    #To enable trust for a specific VF (e.g. VF 0), run:
    ip link set $pf_name vf $vf_index trust $trust_val
    #To disable trust for a specific VF (e.g. VF 0), run:
    # ip link set ens785f1 vf 0 trust off
}

vf_spoof_config()
{
    local pf_name=$1
    local vf_index=$2
    local spoof_val=$3
    #To Turn HW packet source mac spoof check on or off for the specified VF, run:
    #ip link set <pf> vf <vf_index> spoofchk on|off
    #For example, configure for a VF mac of 00:52:44:11:22:33 and turn on spoof-checking (the default is off).
    #ip link set eth2 vf 1 mac 00:52:44:11:22:33 
    ip link set $pf_name vf $vf_index spoofchk $spoof_val
}


vf_link_config()
{
    # It is possible to change the link state as seen by the VF. The set options are:
    # - auto: a reflection of the PF link state (default)
    # - enable: lets the VF to communicate with other VFs on this host even if the PF link state is down
    # - disable: causes the HW to drop any packets sent by the VF.
    # #ip link set <pf> vf <vf_index> state auto|enable|disable
    # For example, set the link state to "down" of a given VF:
    # #ip link set eth2 vf 1 state disable
    # To verify configuration use ip link show command
    # # ip link show dev eth2 
    # 7: eth2: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000 
    # link/ether 00:02:c9:e6:01:12 brd ff:ff:ff:ff:ff:ff 
    # vf 0 MAC 00:00:00:00:00:00, vlan 4095, spoof checking off, link-state auto 
    # vf 1 MAC 00:00:00:00:00:00, vlan 4095, spoof checking on, link-state enable 
    # vf 2 MAC 00:00:00:00:00:00, vlan 4095, spoof checking off, link-state disable 
    # vf 3 MAC 00:00:00:00:00:00, vlan 4095, spoof checking off, link-state auto 
    # vf 4 MAC 00:00:00:00:00:00, vlan 4095, spoof checking off, link-state auto 
    # vf 5 MAC 00:00:00:00:00:00, vlan 4095, spoof checking off, link-state auto
    # Note: "vlan 4095" means VGT mode where the guest is allowed to send anything they want, untagged or tagged with whatever vlan ID. 
    # There's no concept of "allowed VLANs" in Linux.
    local pf_name=$1
    local vf_index=$2
    local state_val=$3
    ip link set $pf_name vf $vf_index state $state_val

}

#This feature only supported by i40e driver
vf_port_mirror_config()
{
    echo ""
}

ovs_with_linux_bond()
{
    local bond_name=$1
    local bond_parater=$2
    local slaves=($3)
    # modprobe bonding miimon=100 mode=4 lacp_rate=1
    # ip link add name bond10 type bond
    # ifenslave bond10 eth4 eth5
    # ip link set dev bond10 up
    # ifenslave bond10 eth4 eth5
    modprobe bonding $bond_parater
    ip link add name $bond_name type bond
    ip link set dev $bond_name up 
    for i in "${slaves[@]}"
    do
        ip link set $i up 
    done
    ifenslave $bond_name "${slaves[@]}"
    
    #ovs-vsctl add-port br-vlan bond10
}

ovs_bond_config()
{
    local bridge_name=$1
    local bond_name=$2
    local slaves=$3
    local paramter=$4
    # ovs-vsctl add-bond ovsbr1 bond0 p1p1_1 p1p2_1 lacp=active
    # ovs-appctl lacp/show <bond name>
    ovs-vsctl add-bond $bridge_name $bond_name $slaves $paramter
    ovs-appctl bond/show
}

ovs_dpdk_bond_config()
{
    local nic1_mac=$1
    local nic2_mac=$2
    local bond_mode=$3
    local mtu=$4
    enable_dpdk $nic1_mac $nic2_mac
    bonding_nic $nic1_mac $nic2_mac $bond_mode $mtu
}

vf_create_and_del_test()
{
    local nic_name
    if i_am_server; then
        nic_name=`pytool get_nic_name_from_mac $SERVER_NIC1_MAC`
        #add test
        vf_create $nic_name 1
        local all_vf=`pytool sriov_get_vf_list $nic_name`
        rlAssertEquals "Check Vf num" "${#all_vf[@]}" "1"
        #delete test
        vf_create $nic_name 0
        all_vf=`pytool sriov_get_vf_list $nic_name`
        rlAssertEquals "Check Vf num" "${#all_vf[@]}" "0"

    elif i_am_client; then
        rlPass "Pass for vf create and del test"
    else
        echo "Here wrong rule"        
    fi
}

vf_mtu_change_test()
{
    local vf_name=$1
    local mtu_val=$2
    vf_mtu_change $1 $2
    local cur_mtu=`cat /sys/class/net/$vf_name/mtu`
    rlAssertEquals "Check mtu config is or not right" $cur_mtu $mtu_val
}

add_bridge_interface_to_xml()
{
    # <interface type="bridge">
    #   <source bridge="ovsbr0"/>
    #   <mac address="00:de:ad:01:01:08"/>
    #   <target dev="vnet0"/>
    #   <model type="virtio"/>
    #   <virtualport type="openvswitch"/>
    #   <address type="pci" domain="0" bus="4" slot="0" function="0"/>
    # </interface>

    local br_name=$1
    local mac_addr=$2
    local bus_info=$3
    pushd $CASE_PATH
    if [[ -f g1.xml ]]
    then
        local result=""
        result=`cat g1.xml | virt-xml --remove-device --network type=vhostuser`
        test -n "$result" && echo "$result" > g1.xml
        result=""

        local cmd="cat g1.xml | virt-xml --add-device --network "
        local para="
        bridge=$br_name,\
        mac="$mac_addr",\
        model=virtio,\
        virtualport_type=openvswitch,\
        address.type=pci,\
        address.domain=0x0000,\
        address.bus="$bus_info",\
        address.slot=0x0,\
        address.function=0x0"
        para=${para// /}
        result=`eval ${cmd}${para}`

        test -n "$result" && echo "$result" > g1.xml
    else
        echo "Can not Find the guest xml file named g1.xml "
    fi
    popd
}

add_vhostuser_interface_to_xml()
{
    # <interface type="vhostuser">
    #   <source type="unix" path="/tmp/vhost0" mode="server"/>
    #   <mac address="00:de:ad:01:01:08"/>
    #   <target dev="eth1"/>
    #   <model type="virtio"/>
    #   <address type="pci" domain="0" bus="16" slot="0" function="0"/>
    #   <driver name="vhost"/>
    # </interface>

    local mac_addr=$1
    local target=$2
    local bus_info=$3
    local source_path=$4
    local source_mode=$5

    pushd $CASE_PATH
    if [[ -f g1.xml ]]
    then
        local result=""
        result=`cat g1.xml | virt-xml --remove-device --network type=vhostuser`
        test -n "$result" && echo "$result" > g1.xml
        result=""
        
        local cmd="cat g1.xml | virt-xml --add-device --network "
        
        local para="
        type=vhostuser,\
        mac="$mac_addr",\
        driver_name=vhost,\
        target="$target",\
        model=virtio,\
        address.type=pci,\
        address.domain=0x0000,\
        address.bus="$bus_info",\
        address.slot=0x0,\
        address.function=0x0,\
        source_type=unix,\
        source_path="$source_path",\
        source_mode=$source_mode"
        para=${para// /}
        result=`eval ${cmd}${para}`

        test -n "$result" && echo "$result" > g1.xml
    else
        echo "Can not Find the guest xml file named g1.xml "
    fi
    popd

}

add_hostdev_interface_to_xml()
{
    echo ""
}

init_linux_bond_ovs_bridge()
{
    local br_name=$1
    modprobe openvswitch
	systemctl stop openvswitch
	sleep 3
	systemctl start openvswitch
	sleep 3
	ovs-vsctl --if-exists del-br ovsbr0
	sleep 5

	systemctl restart openvswitch
	sleep 3
	ovs-vsctl add-br $br_name
}

connection_ping_check()
{
    local cmd=$1
    local tty_console=`virsh ttyconsole guest30032`
    local result=`pytool run_cmd_get_output $tty_console "$(echo $cmd)"`
    if test -n "$result"
    then
        echo "$result"
        rlPass "Ping Is ok ."
    else
        rlFail  "Failed to check ping "
    fi
}

#Test item 
ovs_linux_bond_functional_test()
{
    clear_env
    local bond_mode=$1
    pushd $CASE_PATH
        test -f g1.xml && rm -f g1.xml 
    popd

    local nic1_name
    local nic2_name
    if i_am_server; then
        nic1_name=`pytool get_nic_name_from_mac $SERVER_NIC1_MAC`
        nic2_name=`pytool get_nic_name_from_mac $SERVER_NIC2_MAC`
        vf_create $nic1_name 1
        vf_create $nic2_name 1
	
        local vf1_name=`py_sriov sriov_get_vf_name_from_pf $nic1_name`
        local vf2_name=`py_sriov sriov_get_vf_name_from_pf $nic2_name`
        local slaves=($vf1_name $vf2_name)
        #bond active backup mode test
        ovs_with_linux_bond "bond0" "miimon=100 mode=1" \""${slaves[@]}"\"
        init_linux_bond_ovs_bridge ovsbr0
        ovs-vsctl add-port ovsbr0 bond0        
        test -f g1.xml || cp guest.xml g1.xml
        add_bridge_interface_to_xml ovsbr0 '52:54:00:11:8f:ea' "16"
        start_guest
        configure_guest $SERVER_GUEST_IP
        sync_set CLIENT OVS_LINUX_BOND_SERVER_READY
        connection_ping_check "ping $CLIENT_GUEST_IP -c 100"
        sync_set CLIENT OVS_LINUX_BOND_SERVER_PING_FIN

    elif i_am_client; then
        nic1_name=`pytool get_nic_name_from_mac $CLIENT_NIC1_MAC`
        nic2_name=`pytool get_nic_name_from_mac $CLIENT_NIC2_MAC`
        vf_create $nic1_name 1
        vf_create $nic2_name 1
        local vf1_name=`py_sriov sriov_get_vf_name_from_pf $nic1_name`
        local vf2_name=`py_sriov sriov_get_vf_name_from_pf $nic2_name`
        local slaves=($vf1_name $vf2_name)
        #bond active backup mode test
        ovs_with_linux_bond "bond0" "miimon=100 mode=1" "${slaves[@]}"
        init_linux_bond_ovs_bridge ovsbr0
        ovs-vsctl add-port ovsbr0 bond0        
        test -f g1.xml || cp guest.xml g1.xml
        add_bridge_interface_to_xml ovsbr0 '52:54:00:11:8f:eb' "16"
        start_guest
        configure_guest $CLIENT_GUEST_IP
        sync_wait SERVER OVS_LINUX_BOND_SERVER_READY
        sync_wait SERVER OVS_LINUX_BOND_SERVER_PING_FIN
    else
        echo "Here wrong rule"        
    fi
}

ovs_linux_bond_performance_test()
{
    echo ""
}

ovs_bond_functional_test()
{
    echo ""
}

ovs_bond_performance_test()
{
    echo ""
}

ovs_dpdk_bond_functional_test()
{
    echo ""
}

ovs_dpdk_bond_performance_test()
{
    echo ""
}

function init_test_env()
{
    if i_am_server;then
        local SERVER_NIC1_NAME=`get_nic_name_from_mac $SERVER_NIC1_MAC`
        SERVER_NUMA=$(cat /sys/class/net/${SERVER_NIC1_NAME}/device/numa_node)
        ISOLCPUS_SERVER=`get_isolate_cpus "$SERVER_NIC1_NAME"`
        SERVER_PMD_CPU_MASK=`get_pmd_masks "$ISOLCPUS_SERVER"`
    elif i_am_client;then
        local CLIENT_NIC1_NAME=`get_nic_name_from_mac $CLIENT_NIC1_MAC`
        CLIENT_NUMA=$(cat /sys/class/net/${CLIENT_NIC1_NAME}/device/numa_node)
        ISOLCPUS_CLIENT=`get_isolate_cpus "${CLIENT_NIC1_NAME}"`
        CLIENT_PMD_CPU_MASK=`get_pmd_masks "$ISOLCPUS_CLIENT"`
    else
        echo "error server role"
        true
    fi

    echo "SERVER NUMA IS "$SERVER_NUMA
    echo "SERVER ISOLATED CPUS IS "$ISOLCPUS_SERVER
    echo "SERVER PMD CPU MASK IS "$SERVER_PMD_CPU_MASK
    echo "CLIENT NUMA IS "$CLIENT_NUMA
    echo "CLIENT ISOLATED CPUS IS "$ISOLCPUS_CLIENT
    echo "CLIENT PMD CPU MASK IS "$CLIENT_PMD_CPU_MASK
}

#Here Begin ALL test for FD nic partition 
# All Test Items Based on SRIOV VF
# linux bond 
# ovs bond with linux kernel port
# OVS DPDK BOND 
TEMP_FILE=/tmp/FD_NIC_PARTITION_FOR_BOND

rlJournalStart
rlPhaseStartSetup
if [[ ! -f $TEMP_FILE ]]
then
    rlRun add_epel_repo
    rlRun add_yum_profiles
    rlRun install_init_package
    rlRun install_package
    rlRun install_ovs
    rlRun install_driverctl
    rlRun install_dpdk
    rlRun init_python_env
	rlRun "touch $TEMP_FILE"
	rlRun config_hugepage
fi
rlPhaseEnd

if [[ ! -f $TEMP_FILE ]]
then
    rlFail "FD nic partition for bond init failed please check"
    exit 1
fi

rlPhaseStartTest "FD nic partition for bond Start "
    rlRun "cat /proc/cmdline"
    rlRun init_python_env
    rlRun init_test_env
    rlRun ovs_linux_bond_functional_test 1 
rlPhaseEnd


rlJournalPrintText
rlJournalEnd
